-----
### 해싱의 구조
-----
1. 어떤 회사의 직원이 100명이 있다고 가정
   - 100명의 직원들은 0부터 99까지의 아이디를 부여
   - 단순히 크기가 100인 배열을 만들면 직원들에 대한 정보를 가장 빠르게 저장하고 탐색 가능
   - 자료를 저장하거나 탐색하려면 직원의 아이디를 키(배열의 인덱스)로 생각하고 단지 배열의 특정 요소를 읽거나 쓰면 됨
   - 시간 복잡도는 $O(1)$, 즉 상수 시간 안에 종료 가능
   - 그러나, 탐색 키들이 문자열이거나 매우 큰 숫자이므로 탐색 키를 직접 배열의 인덱스로 사용하기에는 무리가 있으므로 각 탐색 키를 작은 정수로 사상(Mapping)시키는 함수 필요
<div align="center">
<img src="https://github.com/user-attachments/assets/9c29b869-c595-4c18-a7bf-5aaa9bdefee8">
</div>

2. 해싱에서는 자료를 저장하기 위해 배열 사용
   - 배열은 단점도 있지만, 원하는 항목이 들어 있는 위치를 알고 있다면 매우 빠르게 자료 삽입 및 꺼낼 수 있음
   - 이 경우, 배열의 다른 요소들에는 접근할 필요가 없음

3. 해싱(Hashing) : 어떤 항목의 키만을 가지고 바로 항목이 들어 있는 배열의 인덱스를 결정하는 기법
4. 해시 함수(Hash Function) : 키를 입력 받아 해시 주소(Hash Address)를 생성하고 이 해시 주소를 해시 테이블(Hash Table)의 인덱스로 사용
   - 이 배열의 인덱스 위치에 자료를 저장할 수도 있고, 저장된 자료를 꺼낼 수도 있음
   - 예) 영어 사전에는 단어가 키가 되고, 이 단어를 해싱 함수를 이용해 적절한 정수 $i$로 변환한 다음, 배열 요소 $ht[i]$에 단어의 정의를 저장하는 것
<div align="center">
<img src="https://github.com/user-attachments/assets/4f394e3a-1523-4c3f-bf9a-e2f2bd2661d3">
</div>

5. 해싱의 탐색 구조
   - 키 값 $k$를 입력받아 해시 함수 $h(k)$로 연산한 결과 해시 주소 $h(k)$를 인덱스로 사용하여 해시 테이블에 있는 항목에 접근
   - 해시테이블 $ht$에는 $M$개의 버킷(Bucket)으로 이루어진 테이블로서, $ht[0], ht[1], ..., ht[M-1]$의 원소를 가짐
   - 하나의 버킷은 $S$개의 슬롯(Slot)을 가질 수 있으며, 하나의 슬롯에는 하나의 항목이 저장
   - 하나의 버킷에 여러 개 슬롯을 두는 이유는 서로 다른 두 개의 키가, 해시함수에 의해 동일한 해시 주소로 변환될 수 있으므로 여러 개 항목을 동일한 버킷에 저장하기 위함
   - 그러나 대부분 하나의 버킷은 하나의 슬롯을 가짐
<div align="center">
<img src="https://github.com/user-attachments/assets/4b5b65fa-a489-42ba-b0b3-52dd680a74c5">
</div>

   - 해시 테이블에 존재하는 버킷의 수가 M이므로 해시함수 $h$는 모든 키에 대해 $0 ≤ h(x) ≤ M-1$의 범위의 값을 제공해야 함
   - 대부분의 경우, 해시 테이블의 버킷 수는 모든 키의 경우의 수보다 매우 작으므로 여러 개의 서로 다른 키가 해시함수에 의해 같은 해시 주소로 사상(Mapping)되는 경우가 자주 발생
   - 충돌(Collision) : 서로 다른 두 개의 키 $k1, k2$에 대하여 $h(k1) = h(k2)$인 경우를 뜻하며, 키 $k1, k2$를 동의어(Synonym)이라고 함
     + 만약, 충돌이 발생하면 같은 버킷에 있는 다른 슬롯에 항목을 저장
     + 충돌이 자주 발생하면 버킷 내부에서의 순차 탐색 시간이 길어져 탐색 성능이 저하될 수 있으므로 해시 함수를 수정해주거나 해시테이블의 크기를 적절히 조절해줘야 함
   - 오버플로우(Overflow) : 충돌이 버킷에 할당된 슬롯 수보다 많이 발생하게 되면 버킷에 더 이상 항목을 저장할 수 없게 되는 것을 의미
     + 만약, 버킷 당 슬롯의 수가 하나($S = 1$)라면, 충돌이 곧 오버플로우
     + 오버플로우가 발생하면 더 이상 항목을 저장할 수 없게 되므로 오버플로우를 해결하기 위한 방법이 반드시 필요

6. 이상적인 해싱
   - 예) 대학교에서의 학생들의 인적사항을 해싱으로 저장
     + 해싱 테이블에는 학생들의 주민등록번호 / 학번 / 이름 / 주소와 같은 인적 사항 저장
     + 학번을 키로 가정 : 학번은 5자리로 구성, 앞의 2개의 숫자는 학과, 뒤의 3자리 숫자는 각 학과의 학생들의 번호
     + 만약, 같은 학과 학생들만 저장된다고 가정하면 키로 뒤의 3자리만 사용 가능
     + 이 경우, 해시 함수는 단순히 5개의 숫자 중 뒤의 3자리만 추출하면 됨
<div align="center">
<img src="https://github.com/user-attachments/assets/158dfcac-1f91-4618-86d8-ea412a091fe0">
</div>

   - 어떤 학생의 학번이 01023이라면, 이 학생의 인적사항은 해시 테이블의 이름을 ht라고 할 때, $ht[23]$에 저장
     + 이 경우, 해시 테이블에 자료를 저장하는데 필요한 시간 : $O(1)$
     + 즉, 해시 함수를 계산하는 시간만 필요
     + 마찬가지로 자료를 꺼내는 절차도 돋일하며, 학번을 가지고 해시 함수를 게산하여 나온 위치에 있는 자료를 꺼내면 됨

<div align="center">
<img src="https://github.com/user-attachments/assets/87ab32ec-5143-4b3d-8d6c-c406842789d5">
</div>

   - 따라서, 이상적인 경우 해싱은 매우 빠르게 자료를 저장 및 탐색 가능
   - 여기서, 자료를 꺼내기 위해 전체 배열을 탐색하지 않았음
   - 자료를 저장하고 탐색하는 간단한 알고리즘
<div align="center">
<img src="https://github.com/user-attachments/assets/974dc5d2-f656-4627-8f04-e07cf0d252d4">
</div>

   - 해시 테이블이 충분한 공간만 가지고 있으면 잘 동작 : 키는 01000부터 01999까지 변화할 수 있고, 해시함수는 0에서 999까지 생성할 것
   - 만약, 해시 테이블이 1000개의 공간을 가지고 있다면, 위의 알고리즘은 완벽하게 작동될 것
   - 즉, 하나의 학번 당 하나의 배열 요소가 할당

7. 실제의 해싱
   - 실제로는 해시 테이블 크기가 제한되어 있으므로, 하나의 키당 해시테이블에서 하나의 공간을 할당 불가
   - 보통의 경우, 키는 매우 많고, 해시 테이블의 크기는 상당한 제약을 받는 것이 일반적인 상황
     + 예) 주민등록번호가 키라고 가정해보면, 만약 키 당 하나의 공간을 할당하는 경우 많은 공간 필요 (주민등록번호는 13자리의 십진수이므로 $10^{13}$개 정도의 공간 필요)
   - 따라서, 일반적인 경우에는 키에 비해 해시 테이블의 크기가 작음
   - 또, 일반적으로 키 중 일부만 사용되므로 전체를 위해 공간을 항상 준비할 필요가 없음
   - 따라서, 더 작은 해시테이블을 사용하는 해시 함수 고안
   - 바로, 키를 해시테이블 크기로 나누어서 그 나머지를 해시 테이블의 주소로 하는 것
     + 정수 $i$를 해시 테이블 크기 $M$으로 나누어서 나머지를 취하면 0에서 $M - 1$까지의 숫자 생성
     + 이 값은 해시 테이블을 위한 유효한 인덱스
     + 나머지 구하는 연산자 mod를 사용하면 해시함수는 다음과 같이 표현

<div align="center">
<img src="https://github.com/user-attachments/assets/e7a48723-5f1e-4d2d-83be-721ead05ad50">
</div>

   - 위의 해시 함수는 완벽한 해시 함수가 아님
   - 따라서, 두 개 이상의 키가 동일한 해시 테이블 공간으로 사상될 수 있음
     + 예) 테이블의 크기가 31이라고 하면, $h(01023)$과 $h(01054)$는 같은 주소로 매핑
   - 이를 충돌이라고 하며, 해싱에서는 충돌을 해결하는 것이 중요

<div align="center">
<img src="https://github.com/user-attachments/assets/21cf9e03-cf08-4b5a-aab2-3359efd1db21">
</div>

   - 하나의 버킷에 여러 슬롯이 있는 경우
     + 에) 해시 테이블에 26개의 버킷이 있고, 각 버킷에는 2개의 슬롯이 할당
     + 여기서의 키는 알파벳으로 되어 있다고 가정
     + 해시함수는 각 키의 첫 문자를 숫자로 바꿈 (a라면 0이고, b라면 1)
<div align="center">
<img src="https://github.com/user-attachments/assets/38fb13f9-4389-432a-8c8b-b8f3c3d0adf4">
</div>

   - (array, binary, bubble, file, digit, direct, zero, bucket) 순으로 키 값이 계속 입력될 경우 다음과 같이 저장
<div align="center">
<img src="https://github.com/user-attachments/assets/1cc33a42-26e9-4165-8578-6378b5ef7283">
</div>

   - 저장되는 과정에서 계속 충돌과 오버플로우 발생
   - 현재까지의 충돌 해결책은 마련되지 않았으므로 오버 플로우가 일어나면 그 키는 저장 불가 (bucket의 경우 오버플로우로 저장되지 않음)
   - 따라서, 실제 해싱에서는 충돌과 오버플로우가 빈번하게 발생하므로 시간 복잡도는 이상적인 경우인 $O(1)$보다 떨어짐


