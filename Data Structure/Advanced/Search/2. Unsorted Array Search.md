-----
### 정렬되지 않은 배열에서의 탐색
-----
1. 순차 탐색 (Sequential Search) : 탐색 방법 중 가장 간단하고 직접적인 탐색 방법
   - 정렬되지 않은 배열의 항목들을 처음부터 마지막까지 하나씩 검사하여 원하는 항목을 찾아가는 방법
   - 탐색의 대상이 되는 배열은 list[]로 가정, 탐색의 범위는 low에서부터 high까지 함수의 매개변수로 주어짐
   - 탐색 함수는 탐색에 성공하면 그 항목이 발견된 위치 반환, 그렇지 않으면 -1 반환
```c
int seq_search(int key, int low, int high) {
    int i;

    for(i = low; i <= high; i++) { // 인덱스 low에서부터 high까지
        if(list[i] == key) {
            return i; // key와 일치하는 값을 찾으면, 탐색에 성공하므로 키 값의 해당 인덱스 반환
        }    
    }

    return -1; // 그렇지 않으면 탐색에 실패하여 -1 반환
}
```

2. 순차 탐색 알고리즘 수행 예
<div align="center">
<img src="https://github.com/user-attachments/assets/a0486cf5-4313-49ca-b1a4-c0863a9f8709">
</div>

  - 리스트의 앞에서부터 탐색값과 일치하는 항목을 찾을 때까지 순차적 탐색
  - 탐색이 만약 성공적으로 수행(탐색값과 일치하는 항목 찾음)하면, 항목의 인덱스 반환
  - 탐색값과 일치하는 항목이 배열 안에 없다면, 반복문 종료 후 -1 반환

3. 개선된 순차 탐색
   - 순차 탐색에서 비교 횟수를 줄이는 방법 : 리스트 전체를 탐색하기 위한 반복문에서 리스트의 끝을 테스트하는 비교 연산이 있고, 반복문 안에 키 값의 비교 연산
   - 리스트의 끝을 테스트하는 비교 연산을 줄이기 위해 리스트의 끝에 찾고자 하는 키 값을 저장하고, 반복문의 탈출 조건을 키 값을 찾을 때까지 설정하도록 수정
```c
int seq_search2(int key, int low, int high) {
    int i;

    list[high + 1] = key; // 가장 마지막 인덱스에 key값 저장

    for(i = low; list[i] != key; i++) { // list[i]가 key값을 찾을 때까지 반복
        ;
    }

    if(i == (high + 1)) return -1; // high + 1, 즉 맨 끝 인덱스에 도달하면 탐색 실패한 것이므로 -1 반환
    return i; // 그렇지 않으면 탐색에 성공하여 해당 위치 반환
}
```
   - 탐색이 성공할 때는 반복문의 인덱스 i는 찾은 항목의 위치를 가리키게 되고 이 값을 반환
   - 그렇지 않고, 실패했을 경우에는 -1을 반환
   - 따라서, 비교 연산의 수를 반으로 줄일 수 있으므로 탐색 성능 향상
   - 즉, i 값이 리스트의 끝에 도달하였는지를 매번 비교하지 않아도 됨

4. 개선된 순차 탐색 예
<div align="center">
<img src="https://github.com/user-attachments/assets/091e7fba-1dfe-4c68-920f-40f36c56f723">
</div>

   - 크기가 5인 리스트에서 (a)는 8을 탐색했을 때 탐색 성공 경우, (b)는 2를 탐색했을 때 탐색에 실패하는 경우
   - 만약 리스트에 키 값 2가 없다하더라도 리스트의 마지막에 미리 탐색키 값 2를 저장하였으므로 반복문을 탈출하고, 인덱스 i값이 (high + 1)이 되므로 탐색 실패를 알림

5. 순차 탐색의 시간 복잡도
   - 리스트의 처음부터 탐색을 시작하여 해당 항목을 찾거나 해당 항목을 검색할 때까지 항목의 키 값 비교
   - 따라서, 두 가지 경우로 나눌 수 있음
   - 탐색이 성공하는 경우 : 리스트에 있는 키의 위치에 따라 비교 횟수가 결정되므로 모든 키가 탐색될 확률이 동일하다고 가정할 때 평균 비교 횟수
<div align="center">
<img src="https://github.com/user-attachments/assets/cb35fb13-4686-467a-ab8a-6e61fab6cd7f">
</div>

   - 순차 탐색의 경우 성공할 경우 평균 $(n + 1) / 2$ 비교하고, 탐색이 실패한 경우 $n$번 비교하므로 순차 탐색의 시간 복잡도는 $O(n)$
