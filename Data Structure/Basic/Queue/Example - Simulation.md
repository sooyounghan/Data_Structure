-----
### 큐의 응용 : 시뮬레이션
-----
1. 큐로 주로 컴퓨터로 큐잉이론에 따라 시스템의 특성을 시뮬레이션하여 분석하는데 이용
   - 큐잉모델은 고객에 대한 서비스를 수행하는 서버와 서비스를 받는 고객들로 구성
   - 제한된 수의 서버 때문에 고객들은 서비스를 받기 위해 대기 행렬에서 기다림
   - 이 대기 행렬을 큐로 구현
   - 필요한 정보 : 고객들이 기다리는 평균 대기 시간

2. 서비스를 하는 행원은 한 사람이라고 가정
   - 고객의 대기 행렬은 큐로 시뮬레이션
   - 주어진 시간 동안 고객은 랜덤한 간격으로 큐에 들어옴
   - 고객들의 서비스 시간도 한계값 안에서 랜덤하게 결정
   - 큐에 들어있는 고객들은 순서대로 서비스를 받음
   - 한 고객의 서비스가 끝나면, 큐의 맨 앞에 있는 다른 고객이 서비스를 받기 시작
   - 정해진 시간이 끝나면, 시뮬레이션이 종료되면, 고객들의 평균 대기 시간 계산하여 출력

3. 과정
   - 먼저 현재 시각을 나타내는 clock이라는 변수를 하나 증가
   - [0, 10] 사이 난수를 생성해 3보다 작으면, 새로운 고객이 들어온 것으로 판단
     + 새로운 고객이 들어오면 구조체를 생성하고, 고객 아이디 및 도착 시간과 서비스 시간 등 정보 복사
     + 여기서 고객이 필요로 하는 서비스 시간도 난수로 생성
     + 이 구조체를 enqueue()를 호출해 큐에 저장
     + 전역 변수인 service_time에는 현재 처리 중인 고객의 서비스 시간 저장

   - servie_time이 0 인지, 아닌지를 확인
     + 만약, 0이 아니면 어떤 고객이 서비스를 받고 있는 중임을 의미
     + clock이 하나 증가했으므로, service_time은 하나 감소
     + 만약, service_time이 0이면 현재 서비스를 받는 고객이 없음을 의미
     + 따라서, 큐에서 고객 구조체를 하나 꺼내 서비스 시작
     + 즉, 서비스를 시작한다는 것은 전역 변수 service_time에 고객 서비스 시간 저장

   - 60분의 시간이 지나면 고객들이 기다린 시간을 전부 합하여 화면 출력

4. 구현 코드
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define MAX_QUQUE_SIZE 100

typedef struct {
    int id; // 고객 아이디
    int arrival_time; // 고객 도착 시간
    int service_time; // 고객 서비스 시간
} element; // element 구조체 변경

typedef struct {
    int front; // 큐의 전단을 가리킬 변수
    int rear; // 큐의 후단을 가리킬 변수
    element data[MAX_QUQUE_SIZE]; 
} QueueType; // 큐 타입 구조체

// 오류 함수
void error(char *message) {
    fprintf(stderr, "%s\n", message);
    exit(1);
}

// 큐 초기화 함수
void init_queue(QueueType *q) {
   q->front = q->rear = 0; // front와 rear는 처음 0부터 시작
}

// 큐가 꽉 차있는지 확인하는 함수
int is_full(QueueType *q) {
    // rear + 1의 값에 대해 큐의 크기로 나눴을 때, front 변수와 동일하면 큐는 꽉 차있는 것
    return ((q->rear + 1) % MAX_QUQUE_SIZE == q->front);
}

// 큐가 비어있는지 확인하는 함수
int is_empty(QueueType *q) {
    // 큐의 front와 rear, 즉, 전단과 후단이 같은 위치인 경우는 같은 인덱스 일 때를 의미
    return q->front == q->rear;
}

// 큐 출력 함수
void print_queue(QueueType *q) {
    printf("Queue(front = %d, rear = %d) = ", q->front, q->rear);

    if(!is_empty(q)) {
        int i = q->front; // 현재 front의 위치

        do { // 1번은 무조건 실행
            i = (i + 1) % (MAX_QUQUE_SIZE); // i는 다음 인덱스로 이동 (front는 첫 요소의 앞에 위치하므로)
            printf("%d | ", q->data[i]);
            if(i == q->rear){ // 만약, i가 마지막 요소 인덱스에 도달하면 반복문 종료
                break;
            }
        } while(i != q->front); // 반복은 front - 1 변수까지 반복
    }
    printf("\n");
}



// 큐 요소 삽입 함수
void enqueue(QueueType *q, element item) {
    if(is_full(q)) { // 큐 포화 상태 확인
        error("큐가 포화상태");
        return;
    }

    q->rear = (q->rear + 1) % MAX_QUQUE_SIZE; // rear 인덱스에 대해 먼저 인덱스 증가
    q->data[q->rear] = item; // rear 변수를 이동시킨 후 삽입
}

// 큐 요소 삭제 함수
element dequeue(QueueType *q) {
    if(is_empty(q)) {
        error("큐가 공백상태");
    }

    q->front = (q->front + 1) % MAX_QUQUE_SIZE; // front 인덱스에 대해 먼저 인덱스 증가
    element item = q->data[(q->front)]; // front 변수를 이동시킨 후 삭제
    return item;
}

// 큐 요소 확인
element peek(QueueType *q) {
    if(is_empty(q)) {
        error("큐가 공백상태");
    }

    return q->data[(q->front + 1) % (MAX_QUQUE_SIZE)]; // front를 1 증가 시킨 후, 큐 크기로 나누면, 삭제해야 할 요소 의미
}

int main(void) {
    int minutes = 60; // 총 60분의 시간
    int total_wait = 0; // 총 대기 시간
    int total_customers = 0; // 총 고객
    int service_time = 0; // 서비스 시간
    
    int service_customer;

    QueueType queue;

    init_queue(&queue);

    srand(time(NULL));

    for(int clock = 0; clock < minutes; clock++) {
        // 현재 시간은 0부터 시작해서 60까지 진행 예정

        printf("현재 시각 = %d\n", clock);

        if((rand() % 10 < 3)) {
            // 0 ~ 10 사이 난수를 생성해 3보다 작으면, 새 고객이 들어온 것으로 판단하여 고객 정보 생성 후 저장

            element customer;
            customer.id = total_customers++;
            customer.arrival_time = clock;
            customer.service_time = rand() % 3 + 1; // 서비스 시간 난수로 생성

            enqueue(&queue, customer); // 고객 정보 큐에 저장

            printf("고객 %d이 %d분에 들어왔습니다. 업무 처리 시간 = %d분\n", customer.id, customer.arrival_time, customer.service_time);
        }

        if(service_time > 0) {
            // 서비스 시간이 0 이상이면, 고객이 서비스를 받고 있는 중
            printf("고객 %d이 업무처리 중\n", service_customer);
            service_time--; // clock이 1 증가하면, service_time은 1 감소
        } else {
            // 서비스를 받고 있지 않다면, 새로운 고객 서비스 시작
            if(!is_empty(&queue)) {
                // 큐가 비어있지 않다면, 대기 중인 고객 정보 가져오기
                element customer = dequeue(&queue);

                service_customer = customer.id;
                service_time = customer.service_time;

                printf("고객 %d이 %d분에 업무를 시작합니다. 대기 시간 = %d분\n", customer.id, clock, clock - customer.arrival_time);

                total_wait = (clock - customer.arrival_time) + total_wait; // 총 대기 시간 = (현재 시각 - 고객 도착 시간) + 이전 대기 시간
            }
        }
    }
    printf("전체 대기 시간 = %d 분\n", total_wait);
    return 0;
}
```
  - 실행 결과
```
현재 시각 = 0
현재 시각 = 1
고객 0이 1분에 들어왔습니다. 업무 처리 시간 = 3분
고객 0이 1분에 업무를 시작합니다. 대기 시간 = 0분
현재 시각 = 2
고객 0이 업무처리 중
현재 시각 = 3
고객 0이 업무처리 중
현재 시각 = 4
고객 0이 업무처리 중
현재 시각 = 5
현재 시각 = 6
고객 1이 6분에 들어왔습니다. 업무 처리 시간 = 1분
고객 1이 6분에 업무를 시작합니다. 대기 시간 = 0분
현재 시각 = 7
고객 1이 업무처리 중
현재 시각 = 8
현재 시각 = 9
현재 시각 = 10
현재 시각 = 11
고객 2이 11분에 들어왔습니다. 업무 처리 시간 = 3분
고객 2이 11분에 업무를 시작합니다. 대기 시간 = 0분
현재 시각 = 12
고객 3이 12분에 들어왔습니다. 업무 처리 시간 = 1분
고객 2이 업무처리 중
현재 시각 = 13
고객 2이 업무처리 중
현재 시각 = 14
고객 4이 14분에 들어왔습니다. 업무 처리 시간 = 3분
고객 2이 업무처리 중
현재 시각 = 15
고객 3이 15분에 업무를 시작합니다. 대기 시간 = 3분
현재 시각 = 16
고객 5이 16분에 들어왔습니다. 업무 처리 시간 = 3분
고객 3이 업무처리 중
현재 시각 = 17
고객 4이 17분에 업무를 시작합니다. 대기 시간 = 3분
현재 시각 = 18
고객 4이 업무처리 중
현재 시각 = 19
고객 6이 19분에 들어왔습니다. 업무 처리 시간 = 3분
고객 4이 업무처리 중
현재 시각 = 20
고객 4이 업무처리 중
현재 시각 = 21
고객 7이 21분에 들어왔습니다. 업무 처리 시간 = 2분
고객 5이 21분에 업무를 시작합니다. 대기 시간 = 5분
현재 시각 = 22
고객 5이 업무처리 중
현재 시각 = 23
고객 5이 업무처리 중
현재 시각 = 24
고객 5이 업무처리 중
현재 시각 = 25
고객 8이 25분에 들어왔습니다. 업무 처리 시간 = 2분
고객 6이 25분에 업무를 시작합니다. 대기 시간 = 6분
현재 시각 = 26
고객 9이 26분에 들어왔습니다. 업무 처리 시간 = 1분
고객 6이 업무처리 중
현재 시각 = 27
고객 10이 27분에 들어왔습니다. 업무 처리 시간 = 1분
고객 6이 업무처리 중
현재 시각 = 28
고객 6이 업무처리 중
현재 시각 = 29
고객 7이 29분에 업무를 시작합니다. 대기 시간 = 8분
현재 시각 = 30
고객 7이 업무처리 중
현재 시각 = 31
고객 7이 업무처리 중
현재 시각 = 32
고객 11이 32분에 들어왔습니다. 업무 처리 시간 = 2분
고객 8이 32분에 업무를 시작합니다. 대기 시간 = 7분
현재 시각 = 33
고객 8이 업무처리 중
현재 시각 = 34
고객 12이 34분에 들어왔습니다. 업무 처리 시간 = 1분
고객 8이 업무처리 중
현재 시각 = 35
고객 13이 35분에 들어왔습니다. 업무 처리 시간 = 3분
고객 9이 35분에 업무를 시작합니다. 대기 시간 = 9분
현재 시각 = 36
고객 9이 업무처리 중
현재 시각 = 37
고객 10이 37분에 업무를 시작합니다. 대기 시간 = 10분
현재 시각 = 38
고객 14이 38분에 들어왔습니다. 업무 처리 시간 = 2분
고객 10이 업무처리 중
현재 시각 = 39
고객 11이 39분에 업무를 시작합니다. 대기 시간 = 7분
현재 시각 = 40
고객 11이 업무처리 중
현재 시각 = 41
고객 15이 41분에 들어왔습니다. 업무 처리 시간 = 1분
고객 11이 업무처리 중
현재 시각 = 42
고객 12이 42분에 업무를 시작합니다. 대기 시간 = 8분
현재 시각 = 43
고객 12이 업무처리 중
현재 시각 = 44
고객 16이 44분에 들어왔습니다. 업무 처리 시간 = 2분
고객 13이 44분에 업무를 시작합니다. 대기 시간 = 9분
현재 시각 = 45
고객 13이 업무처리 중
현재 시각 = 46
고객 17이 46분에 들어왔습니다. 업무 처리 시간 = 1분
고객 13이 업무처리 중
현재 시각 = 47
고객 13이 업무처리 중
현재 시각 = 48
고객 14이 48분에 업무를 시작합니다. 대기 시간 = 10분
현재 시각 = 49
고객 18이 49분에 들어왔습니다. 업무 처리 시간 = 3분
고객 14이 업무처리 중
현재 시각 = 50
고객 14이 업무처리 중
현재 시각 = 51
고객 15이 51분에 업무를 시작합니다. 대기 시간 = 10분
현재 시각 = 52
고객 19이 52분에 들어왔습니다. 업무 처리 시간 = 2분
고객 15이 업무처리 중
현재 시각 = 53
고객 20이 53분에 들어왔습니다. 업무 처리 시간 = 1분
고객 16이 53분에 업무를 시작합니다. 대기 시간 = 9분
현재 시각 = 54
고객 16이 업무처리 중
현재 시각 = 55
고객 21이 55분에 들어왔습니다. 업무 처리 시간 = 1분
고객 16이 업무처리 중
현재 시각 = 56
고객 22이 56분에 들어왔습니다. 업무 처리 시간 = 2분
고객 17이 56분에 업무를 시작합니다. 대기 시간 = 10분
현재 시각 = 57
고객 17이 업무처리 중
현재 시각 = 58
고객 18이 58분에 업무를 시작합니다. 대기 시간 = 9분
현재 시각 = 59
고객 18이 업무처리 중
전체 대기 시간 = 123 분
```
