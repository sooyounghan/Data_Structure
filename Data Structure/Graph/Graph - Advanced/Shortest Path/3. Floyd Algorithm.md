-----
### Floyd의 최단 경로 알고리즘
-----
1. 그래프에 존재하는 모든 정점 사이의 최단 경로를 구하려면 Dijkstra의 알고리즘을 정점 수 만큼 반복 실해ㅐㅇ
2. 그러나 모든 정점 사이의 최단 거리를 구하려면 더 간단하고 좋은 알고리즘이 존재 : Floyd 최단 경로 알고리즘은 그래프에 존재하는 모든 정점 사이의 최단 경로를 한 번에 모두 찾아주는 알고리즘
3. Floyd의 최단 경로 알고리즘은 2차원 배열 A를 이용해 3중 반복을 하는 루프로 구성
   - 인접 행렬 weight의 구성
     + i == j이면, weight[i][j] = 0으로 설정
     + 만약, 두 개의 정점 i, j 사이에 간선이 존재하지 않으면 weight[i][j] = ∞
     + 정점 i, j 사이에 간선이 존재하면 weight[i][j]는 간선 (i, j)의 가중치가 됨

   - 즉, Floyd 알고리즘은 간단한 삼중 반복문으로 표현되며, A의 초기값은 가중치 행렬인 weight
<div align="center">
<img src="https://github.com/user-attachments/assets/a4a223c0-408b-42a2-ad17-b169daea60bc">
</div>

4. 위 알고리즘에서 $A^k[i][j]$를 0부터 k까지의 정점만을 이용한 정점 i에서 j까지의 최단 경로라고 가정
   - 여기서 $A^{n-1}[i][j]$을 찾으면 되는데, $A^{n-1}[i][j]$는 0부터 $n - 1$까지의 모든 정점을 이용한 최단 경로이기 때문임
   - Floyd 알고리즘의 핵심적인 내용은 $A^{-1} → A^{0} → A^{1} → A^{2} → ...  → A^{n-1}$ 순으로 최단 거리를 구하는 것
     + $A^{-1}$는 weight 배열의 값과 같음
   - 수학적인 귀납법과 비슷한 방법
     + 먼저 $A^{k-1}$까지는 완벽한 최단 거리가 구해졌다고 가정
     + $k$번째 정점이 추가로 고려되는 상황을 생각하면, 0부터 $k$까지 정점만을 사용해 정점 $i$에서 정점 $j$로 가는 최단 경로는 다음 2가지 경우
<div align="center">
<img src="https://github.com/user-attachments/assets/c68123f5-67e8-4ed9-9e1b-2d00709a12c0">
</div>

   - 정점 k를 거쳐서 가지 않는 경우 : $A^{k}[i][j]$는 $k$보다 큰 정점을 통과하지 않으므로 이 경우 최단 거리는 $A^{k-1}[i][j]$
   - 정점 k를 통과하는 경우 : $i$에서 $k$까지의 $A^{k-1}[i][k]$에다가 $k$에서 $j$까지의 최단 거리인  $A^{k-1}[i][j]$를 더한 값

   - 따라서, 최종적인 최단 거리는 당연히 위 두 가지 중 더 적은 값이 될 것
   - 최종적으로, $A^{k-1}[i][k]$와 $A^{k-1}[i][k] + A^{k-1}[k][j]$ 중 보다 적은 값이 $A^{k}[i][j]$
   - 이는 정점 $k$를 경유하는 것봐 좋은 경로이면, $A^{k-1}[i][k]$의 값이 변경, 그렇지 않으면 이전 값 유지
<div align="center">
<img src="https://github.com/user-attachments/assets/af2a4b00-11fa-41be-9702-3f528f795210">
<img src="https://github.com/user-attachments/assets/16c4fe9e-e256-43b2-a0f4-5d5d6431747d">
</div>

5. 구현
```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define TRUE 1
#define FALSE 0

#define MAX_VERTICES 100
#define INF 1000000 // 무한대 (연결이 없는 경우 의미)

typedef struct GraphType { // 그래프 타입 구조체 정의
    int n; // 정점의 개수
    int weight[MAX_VERTICES][MAX_VERTICES]; // 가중치 간선 배열
} GraphType;

int A[MAX_VERTICES][MAX_VERTICES]; 

void printA(GraphType* g) {
    int i, j;
    
    printf("=========================\n");
    for(i = 0; i < g->n; i++) {
        for(j = 0; j < g->n; j++) {
            if(A[i][j] == INF) { // A[i][j] 간선 값이 없으면 * 출력력
                printf(" * ");    
            } else {
                printf("%3d ", A[i][j]); // 그렇지 않으면 간선 표시
            }
        }
        printf("\n");
    }

    
    printf("=========================\n");
}
// Floyd 알고리즘을 이용한 최단 경로 
void floyd(GraphType* g) {
    int i, j, k;

    for(i = 0; i < g->n; i++) {
        for(j = 0; j < g->n; j++) {
            A[i][j] = g->weight[i][j]; // A^-1 상태
        }
    }

    printA(g);

    for(k = 0; k < g->n; k++) {
        for(i = 0; i < g->n; i++) {
            for(j = 0; j < g->n; j++) {
                if(A[i][k] + A[j][k] < A[i][j]) { // (i, j) 간선 경로보다 (i, k) + (k, j)의 간선 값이 작다면,
                    A[i][j] = A[i][k] + A[j][k]; // 그 값으로 변경    
                }
            }
        }
        printA(g);
    }
}

int main(void) {
    GraphType g = { 7,
    { { 0, 7, INF, INF, 3, 10, INF },
    { 7, 0, 4, 10, 2, 6, INF },
    { INF, 4, 0, 2, INF, INF, INF},
    { INF, 10, 2, 0, 11, 9, 4},
    { 3, 2, INF, 11, 0, INF ,5 },
    { 10, 6, INF, 9, INF, 0, INF },
    { INF, INF, INF, 4, 5, INF, 0} }
    };

    floyd(&g); // 0번 정점에 대한 최단 경로
    return 0;
}
```
  - 실행 결과
```
=========================
  0   7  *  *   3  10  * 
  7   0   4  10   2   6  * 
 *   4   0   2  *  *  * 
 *  10   2   0  11   9   4 
  3   2  *  11   0  *   5 
 10   6  *   9  *   0  * 
 *  *  *   4   5  *   0 
=========================
=========================
  0   7  *  *   3  10  * 
  7   0   4  10   2   6  * 
 *   4   0   2  *  *  * 
 *  10   2   0  11   9   4
  3   2  *  11   0  13   5
 10   6  *   9  13   0  *
 *  *  *   4   5  *   0
=========================
=========================
  0   7  11  17   3  10  *
  7   0   4  10   2   6  *
 11   4   0   2   6  10  *
 17  10   2   0  11   9   4
  3   2   6  11   0   8   5
 10   6  10   9   8   0  *
 *  *  *   4   5  *   0
=========================
=========================
  0   7  11  13   3  10  *
  7   0   4   6   2   6  *
 11   4   0   2   6  10  *
 13   6   2   0   8   9   4
  3   2   6   8   0   8   5
 10   6  10   9   8   0  *
 *  *  *   4   5  *   0
=========================
=========================
  0   7  11  13   3  10  17
  7   0   4   6   2   6  10
 11   4   0   2   6  10   6
 13   6   2   0   8   9   4
  3   2   6   8   0   8   5
 10   6  10   9   8   0  13
 17  10   6   4   5  13   0
=========================
=========================
  0   5   9  11   3  10   8
  5   0   4   6   2   6   7
  9   4   0   2   6  10   6
 11   6   2   0   8   9   4
  3   2   6   8   0   8   5
 10   6  10   9   8   0  13
  8   7   6   4   5  13   0
=========================
=========================
  0   5   9  11   3  10   8 
  5   0   4   6   2   6   7
  9   4   0   2   6  10   6
 11   6   2   0   8   9   4
  3   2   6   8   0   8   5
 10   6  10   9   8   0  13
  8   7   6   4   5  13   0
=========================
=========================
  0   5   9  11   3  10   8
  5   0   4   6   2   6   7
  9   4   0   2   6  10   6
 11   6   2   0   8   9   4
  3   2   6   8   0   8   5
 10   6  10   9   8   0  13
  8   7   6   4   5  13   0
=========================
```

6. 분석
   - 두 개의 정점 사이의 최단 경로를 찾는 Dijkstra 알고리즘의 시간 복잡도 : $O(n^2)$
     + 모든 정점의 쌍의 최단 경로를 구하려면 Dijkstra 알고리즘을 $n$번 반복해야 하므로 전체 복잡도는 $O(n^3)$
   - 한 번에 모든 정점 간의 최단 경로를 구하는 Floyd 알고리즘은 3중 반복문이 실행 : $O(n^3)$
   - 즉, 두 알고리즘의 차이는 없음
   - 하지만, Floyd 알고리즘은 매우 간결한 반복 구문을 사용하므로 Dijkstra 알고리즘 보다 상당히 빨리 모든 정점 간 최단 경로를 찾을 수 있음
