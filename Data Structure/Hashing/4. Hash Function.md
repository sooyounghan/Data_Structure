-----
### 해시함수
-----
1. 해싱에서는 키 값을 해시 테이블의 주소로 변환하는 해시 함수가 잘 설계되어야만 탐색 효율 증대
2. 좋은 해시 함수의 조건
   - 충돌이 적어야 함
   - 해시함수 값이 해시테이블의 주소 영역 내 고르게 분포되어야 함
   - 계산이 빨라야 함
<div align="center">
<img src="https://github.com/user-attachments/assets/2bd24424-4c4a-40c6-9288-a1d0d8ea6ed1">
</div>

3. 예) 영문으로 되어 있는 은행 지점명의 첫 글자를 해시함수로 사용하는 것은 균일하지 않음
   - x로 시작하는 지점명은 별로 없는 등의 문제
   - 즉, 해시 테이블을 균일하게 사용하지 않음

4. 따라서, 해시 테이블의 크기가 M인 경우 해시 함수는 키(주로 정수나 문자열)들을 [0, M - 1]의 범위의 정수로 변환

-----
### 제산 함수
-----
1. 나머지 연산자(mod)를 사용하여 키를 해시 테이블의 크기로 나눈 나머지를 해시 주소로 사용하는 방법
2. 즉, 키 $k$에 대해 해시함수는 h(k) = k mod M
   - $M$은 해시 테이블의 크기로서 해시 함수의 값의 범위는 $0$ ~ $(M - 1)$
   - 해시 테이블의 인덱스로 사용하기 아주 이상적인 값
   - 이는 가장 일반적인 해시 함수로서, 해시 테이블의 크기는 주로 소수(Prime Number) 선택
   - 이 방법은 다양한 응용 분야에 쉽게 적용 가능 및 해시 주소를 상당히 고르게 분포시킬 수 있는 좋은 ㅂ아법

3. $M$의 선택이 중요한 이유
   - 예를 들어, $M$이 짝수라면 k mod M은 $k$가 짝수이면 짝수가 되고, $k$가 홀수이면 홀수가 됨
   - 만약, 메모리 주소를 가지고 해싱을 한다면, $k$가 짝수가 될 가능성이 높고(메모리 주소는 주로 2의 배수), 이런 식으로 해시 주소가 한쪽으로 편향되면 해시 테이블을 골고루 사용하지 않으므로, 결과적으로 좋지 않음
   - 따라서, 테이블의 크기 $M$은 항상 홀수여야 하며, 만약 $M$이 소수라면, 자기 자신과 1만을 약수로 가지는 수이므로 k mod M은 0에서 $M - 1$을 골고루 사용하는 값을 만듬
4. 나머지 연산을 수행했을 때 음수가 나올 가능성에 대비 : k mod M이 음수라면, 여기서 $M$을 더해 결과값이 항상 0에서 $M - 1$이 되도록 해야 함
5. 최종적인 해시 함수
```c
int hash_function(int key) {
    int hash_index = key % M; // key 값을 해시 테이블의 크기 M으로 나눔
    if(hash_index < 0) { // 만약, 해시 인덱스가 음수라면,
        hash_index += M; // M을 더함
    }
    return hash_index; // 해시 인덱스 반환
}
```

-----
### 폴딩 함수
-----
1. 주로 키가 해시 테이블보다 크기가 더 큰 정수의 경우
   - 예) 키는 32비트이고, 해시 테이블의 인덱스는 16비트 정수인 경우
     + 이런 경우, 키의 앞의 16비트 무시, 뒤의 16비트를 해시 코드로 사용하면, 앞의 16비트만 다르고, 뒤의 16비트가 같을 경우 충돌 발생

2. 따라서, 키의 일부만 사용하는 것이 아닌, 키를 몇 개의 부분으로 나누어 더하거나 비트별로 XOR 같은 Bool 연산을 사용하는 것이 좋은데, 이를 폴딩(Folding)
   - 예) 32비트 키를 2개의 16비트로 나누어 비트별로 XOR 연산하는 코드
```c
hash_index = (short) (key ^ (key >> 16)); // key를 16비트로 나누어 XOR
```

3. 폴딩 함수는 키를 여러 부분을 나누어 모두 더한 값을 해시 주소로 사용
   - 키를 나누고 더하는 방법에는 이동 폴딩(Shift Folding), 경계 폴딩(Boundary Folding) 존재
   - 이동 폴딩 : 키를 여러 부분으로 나눈 값들을 더해 해시 주소로 사용
   - 경계 폴딩 : 키의 이웃한 부분을 거꾸로 더하여 해시 주소를 얻음
   - 폴딩 방법을 구현할 때에는 키 값을 해시 테이블의 크기만큼 수를 가지는 부분으로 분할한 후, 분할된 부분을 합해 해시 주소를 만듬
   - 예) "12320324111220"인 키의, 해시 주소가 10진수 3자리로 구성되어 있는 경우 이동 폴딩과 경계 폴딩의 예
<div align="center">
<img src="https://github.com/user-attachments/assets/6910cacc-acad-4e70-abb2-ce66a469667a">
</div>

------
### 중간 제곱 함수
------
1. 키를 제곱한 다음, 중간의 몇 비트를 취해서 해시 주소 생성
2. 제곱한 값의 중간 비트들은 대개 키의 모든 문자들과 관련이 있으므로 서로 다른 키는 몇 개의 문자가 같을지라도 서로 다른 해싱 주소를 가짐
3. 따라서, 키 값을 제곱한 값의 중간 비트들의 값은 비교적 고르게 분산

-----
### 비트 추출 방법
-----
1. 해시 테이블의 크기가 $M = 2^k$일 때, 키를 이진수로 간주해 임의의 위치의 $k$개의 비트를 해시 주소로 사용
2. 아주 간단하지만, 키의 일부 정보만 사용하므로 해시 주소의 집중 현상 발생 가능성이 높음

-----
### 숫자 분석 방법
-----
1. 숫자로 구성된 키에서 각 위치에 있는 수의 특징을 미리 알고있을 때 유용
2. 키의 각 위치에 있는 숫자 중 편중되지 않는 수들을 해시 테이블의 크기에 적합한 만큼 조합해 해시 주소로 사용
3. 예) 학생의 학번이 '200212345'라고 한다면, 입학년도를 의미하는 앞의 4자릿수는 편중되어있으므로, 가급적 사용하지 않고 나머지를 수를 조합해 해시 주소로 사용

-----
### 탐색키가 문자열일 경우 주의점
-----
1. 키들이 정수일 때는 비교적 쉽게 해시 주소로 변환 가능
2. 하지만 많은 경우, 키들은 문자열일 수 있는데, 문자열로부터 좋은 해시 주소를 생성하는 것이 중요
3. 대개 문자열안의 문자에 정수를 할당하여 바꿈
   - 예) a부터 z까지 1부터 26까지 할당 가능

4. 가장 간단한 방법 : 문자의 아스키 코드 값이나 유니 코드 값 사용
   - 예) book, cup, car, desk 등 문자열을 해시 주소로 변경
     + 이 방법을 사용하면 book, cup은 구별이 가능하지만, cup과 car는 구별이 불가능
     + 따라서, 충돌을 막기 위해 모든 문자를 골고루 사용해야 함

5. 가장 보편적인 방법 : 각 문자의 아스키 코드 값을 모두 더함
   - 이 경우에는 서로 다른 키들이 같은 문자열로 이루어지지 않는 한 비교적 잘 동작
   - 하지만, 키들이 동일한 문자로 이루어져 있지만 위치가 다른 경우, 즉, cup / puc와 같은 키들은 구별 불가
   - 또한, 아스키 문자 코드 범위가 65 ~ 122이므로, 만약 3자리로 이루어진 키의 경우, 195 ~ 366으로 해시 코드 집중

6. 더 좋은 방법 : 글자들의 아스키 코드 값에 위치에 기초한 값을 곱하는 것
   - 문자열 $s$가 $n$개의 문자를 가지고 있다고 가정
   - $s$안의 $i$번째 문자가 $u_i$라고 하면, 해시 주소를 다음과 같이 계산
<div align="center">
<img src="https://github.com/user-attachments/assets/4f3b4ce4-7ea2-46d2-b0ad-d39feeaa3a98">
</div>

   - 여기서 $g$는 양의 정수
   - 계산량을 줄이기 위해 호너의 방법(Horner's Method) 사용 가능
<div align="center">
<img src="https://github.com/user-attachments/assets/3a50fef1-6856-49e7-8cbb-e991970d18b2">
</div>

   - 함수 구현
```c
int hash_function(char *key) {
    int hash_index = 0;

    while(*key) { // 문자열에 대해
        hash_index = g * hash_index + *key++; // 각 한 문자에 대해 인덱스와 양의 정수 g를 통한 계산으로 해시 인덱스 생성
    }

    return hash_index;
}
```
  - 이 방법은 키가 긴 문자열로 되어있으면, 오버플로우 발생 가능 (하지만 C언어에서는 오버플로우를 무시하므로, 여전히 유효한 해시 주소 얻을 수 있음)
  - 보통 g 값으로는 31을 사용
  - 오버플로우가 발생하면 해시 코드의 값이 음수가 될 수 있으므로, 이런 경우 검사해야 함
