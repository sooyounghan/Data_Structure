-----
### 해싱의 성능 분석
-----
1. 해싱에서 가장 중요한 연산은 탐색 연산
   - 즉, 해시 테이블에 자료를 추가하거나 자료를 꺼내거나 자료를 삭제하는 연산들은 모두 탐색 연산 사용
   - 탐색 연산은 2가지 중 하나 : 성공적인 탐색과 실패하는 탐색
  
2. 이상적인 해싱의 시간 복잡도 : $O(1)$
   - 즉, 이 시간 복잡도는 충돌이 전혀 일어나지 않는다는 가정하에서만 가능
   - 이러한 이상적인 해싱 함수를 찾을 수 있지만, 일반적으로는 충돌이 있다고 가정해야 하므로 해싱 탐색 연산은 $O(1)$보다 느려지게 됨

3. 해싱의 성능을 분석하기 위해 해시 테이블이 얼마나 채워져있는지에 대한 척도 필요 : 해시 테이블의 적재 밀도(Loading Density) 또는 적재 비율(Loading Factor)
   - 저장되는 항목의 개수 $n$과 해시 테이블의 크기 $M$의 비율

<div align="center">
<img src="https://github.com/user-attachments/assets/cd237627-1184-432a-b592-f51aa8246190">
</div>

   - 여기서 α가 0이면 해시 테이블은 비어 있음
   - α의 최대값은 충돌 해결 방법에 따라 달라짐
   - 선형 조사법에서는 해시 테이블이 가득찬다면, 각 버킷당 하나의 항목이 저장될 것이므로 1이될 것
   - 체인법에서는 저장할 수 있는 항목의 수가 해시 테이블의 크기를 넘어설 수 있으므로 α는 최대값을 가지지 않음

4. 선형 조사법에서 해시 테이블이 채워지면 충돌이 더 자주 일어날 것인데, 탐색을 위한 비교 연산의 개수
<div align="center">
<img src="https://github.com/user-attachments/assets/1d176419-369f-4411-99b7-e1e449fb93a9">
<img src="https://github.com/user-attachments/assets/5576648b-e03a-4029-8e79-2059e7106804">
</div>

   - 해시 테이블이 절반정도 채워진 상태에서는 실패한 탐색은 2.5 비교 연산 요구
   - 성공한 탐색의 경우 1.5 비교 연산을 요구
   - α가 0.5을 넘어갈수록 실패한 탐색은 급격하게 탐색 시간이 증가하므로, 결론적으로 해시 테이블의 적재 밀도가 0.5를 넘어가지 않도록 해야함

5. 체이닝 방법에서 α가 항목의 개수를 연결 리스트의 개수로 나눈 것이 됨
   - 즉, α는 평균적으로 하나의 연결 리스트 당 몇 개의 항목을 가지고 있느냐가 됨
   - 하나의 키를 찾는데 필요한 비교 연산의 개수
     + 실패하는 탐색을 생각하면 찾고자 하는 위치가 비어있다면 $O(1)$의 시간
     + 평균적인 경우, α만큼의 항목을 탐색해야 함
     + 성공적인 탐색의 경우 항상 연결 리스트에 항목이 존재할 것이고, 평균적으로 α의 항목을 비교하여야 하고, 테이블에 존재하는 포인터까지 생각한다면 1 + α / 2
<div align="center">
<img src="https://github.com/user-attachments/assets/77eca046-6f14-470c-a8ce-c648800007fa">
<img src="https://github.com/user-attachments/assets/03f8bf79-2dc1-47a9-9cf8-51b78a208873">
</div>

   - α가 증가하더라도 성능이 급격하게 떨어지지 않으며, 효율성을 위해 α를 유지할 필요가 없음

6. Lum, Yuen, Dodd의 실험적 연구 결과 - 하나의 키를 탐색하는 데 필요한 평균 버킷 접근수를 적재 밀도, 해시 함수, 오버 플로우 해결 방법에 따른 해싱 성능 평가 결과
<div align="center">
<img src="https://github.com/user-attachments/assets/5b21df01-f6b9-4cfd-b2f1-88cb8c56f370">
</div>

   - 체이닝 사용 방법이 가장 효율적

7. 정리
   - 선형 조사법은 적재 밀도를 0.5 이하로 유지해야 함
   - 이차 조사법과 이중 해싱법에서는 적재 밀도를 0.7 이하로 유지시키는 것이 좋음
   - 선형 조사법은 테이블의 크기에 따라 저장할 수 있는 요소들의 개수에 자연적으로 제한이 가해지지만, 선형 주소법이 적재 밀도가 작은 경우 이차 조사법이나 이중 해싱보다 효율적일 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/5f4100f1-ecff-4f42-a43f-8b7e457e95de">
</div>

   - 체인법은 적재 밀도에 비례하는 성능을 보여줌
     + 즉, 성능을 저하시키지 않고 얼마든지 저장할 수 있는 요소의 개수를 늘릴 수 있다는 것이 장점
     + 링크를 위한 메모리 낭비 문제는 저장되는 자료의 크기에 따라 달라짐
    
   - 해싱을 배열을 이용하는 이진 탐색과 비교하면 해싱이 일반적으로 빠름
     + 삽입이 어려운 이진 탐색과 달리 해싱은 삽입이 쉬우며, 이진 탐색 트리는 현재값보다 다음으로 큰 값이나 다음으로 작은 값을 쉽게 찾을 수 있는 장점이 존재
     + 또한, 이진 탐색 트리는 값의 크기 순으로 순회하는 것이 쉽지만, 해싱은 순서가 없으므로 해시 테이블에 초기 필요 공간 할당이 불명확
     + 또한, 해싱은 최악의 시간 복잡도가 매우 나쁨 : 최악의 경우 모든 값이 하나의 버킷에 집중되는 것으로 시간 복잡도가 $O(n)$이므로, 심각한 응용에서는 부적절한 방법

8. 시간 복잡도 비교
<div align="center">
<img src="https://github.com/user-attachments/assets/fabc4012-7334-426a-8661-bb5e869094d6">
</div>

9. 해싱의 응용 분야
    - 방대한 양의 데이터를 액세스 해야하는 상황에서 널리 사용
    - 해싱을 사용하면 신속하게 정보 검색 가능하므로 다음 전형적인 예에 사용
       + 데이터베이스 인덱싱에 사용 : 일부 데이터베이스 관리 시스템은 별도의 인덱스 파일을 사용하는데, 데이터가 파일에서 추출되어야 할 때, 탐색 키는 먼저 인덱스 파일에서 검색되고, 검색 결과로부터 데이터베이스 파일에서 정확한 위치를 알 수 있음 (인덱스 파일의 키 정보는 종종 해시 테이블로 구현)
       + 컴파일러에서 심볼 테이블 구현에 사용 : 컴파일러는 소스 프로그램에서 사용자가 정의한 모든 식별자(심볼)의 기록 유지를 위해 심볼 테이블을 사용하는데, 해싱을 사용해 변수의 이름이나 함수의 이름을 빠르게 찾을 수 있음
       + 인터넷 검색 엔진에서 널리 사용
