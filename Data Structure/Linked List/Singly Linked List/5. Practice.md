-----
### 단순 연결 리스트에서의 기능 구현
-----
1. insert() : 리스트에 노드를 삽입하는 함수
```c
// 문제 9 : 리스트에 노드를 삽입하는 함수
ListNode* insert(ListNode* head, int num) {
    // 새로운 노드를 동적 할당
    ListNode *new_node = (ListNode *)malloc(sizeof(ListNode));

    if(new_node == NULL) { // 동적할당 실패 시 오류
        error("동적 메모리 할당 실패");
    }

    // 새로운 노드 초기화
    new_node->data = num;
    new_node->link = NULL;

    if(head == NULL) { // 매개변수로 받은 head가 NULL, 즉 아무것도 연결되지 않았으면,
        return new_node; // head는 new_node를 가리킴
    } 

    // 이미 head에 노드가 연결 된 경우
    ListNode *p = head; // p는 노드를 가리킴

    while(p->link != NULL) { // 맨 마지막 노드까지 이동
        p = p->link;    
    }

    p->link = new_node; // 맨 마지막 노드의 link에 new_node 연결

    return head; // head 노드 반환환
}
```

2. list_print() : list_print
```c
// 문제 9 : 리스트 출력 함수
void list_print(ListNode *head) {
    ListNode *p = head; // p는 head를 가리킴

    while(p != NULL) { // 맨 마지막 노드에 다다를 때까지
        printf("%d", p->data); // 데이터 출력
        if(p->link != NULL) { // 맨 마지막 노드는 ->를 표시하면 안 되므로, 이 조건은 p->link != NULL
            printf(" -> ");
        }
        p = p->link; // 다음 노드로 이동
    }

    printf("\n");
}
```

3. list_count() : 리스트의 노드 개수를 확인하는 함수
```c
// 문제 10 : 리스트 노드 개수
int list_count(ListNode *head) {
    ListNode *p = head; // 노드는 head를 가리킴
    int count = 0; // 노드 개수 셀 변수
    
    while(p != NULL) { // 마지막 노드에 도착할 때까지,
        p = p->link; // 다음 노드로 이동
        count++; // 개수는 1개 증가
    }

    return count; // 개수 반환
}
```

4. list_sum() : 단순 연결 리스트에 저장된 모든 노드의 데이터 값을 합하는 함수
```c
// 문제 11 : 단순 연결 리스트에 저장된 모든 노드의 데이터 값을 합하는 함수
int list_sum(ListNode *head) {
    ListNode *p = head;
    int sum = 0;

    while(p != NULL) { // 마지막 노드에 도착할 때까지,
        sum += p->data; // 노드의 존재하는 정수 합 구하기
        p = p->link; // 다음 노드로 이동
    }

    return sum; // 합 반환
}
```

5. list_node_x() : 특정한 값을 갖는 노드의 개수를 계산하는 함수
```c
// 문제 12 : 특정한 값을 갖는 노드의 개수를 계산하는 함수
int list_node_x(ListNode *head, element x) {
    ListNode *p = head;

    int count = 0; // 특정 값을 갖는 노드 개수를 셀 변수

    while(p != NULL) { // 맨 마지막 노드까지 탐색 
        if(p->data == x) { // 특정 값이 존재하면
            count++; // 개수 증가
        }

        p = p->link; // 다음 노드로 이동
    }

    return count; // 총 개수 반환
}
```

6. delete_x() : 특정한 데이터 값을 갖는 노드를 삭제하는 함수
```c
// 문제 13 : 특정한 데이터 값을 갖는 노드를 삭제하는 함수
ListNode* delete_x(ListNode *head, element x) {
    ListNode *p = head; // 맨 처음 노드를 가리킴
    ListNode *prev = NULL; // 현재 노드의 이전 노드 (삭제를 위함)

    while(p != NULL) { // 맨 마지막 노드까지 탐색 
        if(p->data == x) { // 특정 데이터 값을 찾은 경우, 2가지 생각 : 첫 노드를 삭제해야 하는 경우 / 그렇지 않은 경우
           ListNode *delete_node = p; // ListNode는 동적 할당했으므로 동적 할당 해제를 위해 임시 ListNode delete_node 생성 후, 삭제 노드 저장 
           
           if(prev == NULL) { // 만약, 첫 번째 노드 삭제라면 (prev, 즉 이전 노드는 참조값이 없음)
                head = p->link; // 현재 노드의 link 값을 head와 연결
                p = head; // head가 가리키는 곳을 p가 가리킴
           } else { // 첫 번쨰 노드가 아니라면,
                prev->link = p->link; // 이전 노드가 가리키는 다음 노드는 현재 노드가 가리키는 다음 노드
                p = p->link; // 다음 노드로 이동
           }
           free(delete_node); // 삭제할 노드 동적 할당 해제
        } else { // 해당 특정 값이 아니라면,
            prev = p;  // 다음 노드로 이동하기 전, 이전 노드는 이제 현재 노드를 가리킴
            p = p->link; // 다음 노드로 이동
        }
    }

    return head;
}
```

7. list_min(), list_max() : 리스트에서 최댓값과 최솟값을 찾는 함수
```c
// 문제 15 : 리스트에서 최대값과 최소값을 찾는 함수
element list_min(ListNode *head) {
    ListNode *p = head;

    if(p == NULL) { // 리스트의 요소가 아예 없는 경우 찾을 수 없으므로 이를 표시
        printf("최대값과 최소값을 찾을 수 없습니다.\n");
        return;
    }

    element min = p->data; // 아니라면, 처음 최솟값은 첫 번째 노드의 값 

    while(p != NULL) { // 마지막 노드에 다다를 때까지,
        if(p->data < min) { // 최솟값보다 작은 요소를 발견하면 변경
            min = p->data;
        }
        p = p->link; // 다음 노드로 이동
    }

    return min; // 최솟값 반환
}
```
```c
element list_max(ListNode *head) {
    ListNode *p = head;

    if(p == NULL) { // 리스트의 요소가 아예 없는 경우 찾을 수 없으므로 이를 표시
        printf("최대값과 최소값을 찾을 수 없습니다.\n");
        return;
    }

    element max = p->data; // 아니라면, 처음 최댓값은 첫 번째 노드의 값 

    while(p != NULL) { // 마지막 노드에 다다를 때까지,
        if(p->data > max) { // 최댓값보다 큰 요소를 발견하면 변경
            max = p->data;
        }
        
        p = p->link; // 다음 노드로 이동
    }

    return max; // 최댓값 반환
}
```

8. delete_odd_node() : 헤드 포인터가 주어질 때, 첫 번째 노드부터 하나씩 건너서 있는 노드를 전부 삭제하는 함수 (= 즉, 홀수번째 노드들을 전부 삭제하는 함수)
```c
// 문제 16 : 헤드 포인터가 주어질 때, 첫 번째 노드부터 하나씩 건너서 있는 노드를 전부 삭제하는 함수
ListNode* delete_odd_node(ListType *plist) {
    if(plist->head == NULL || plist->tail == NULL) { // 헤더 포인터의 head 또는 tail이 NULL이면, 이는 노드가 없는 것이므로,
        return plist->head; // head를 반환
    }

    ListNode *prev = plist->head; // 이전 노드는 head가 가리키는 노드
    ListNode *delete = plist->head->link; // 삭제할 노드는 head가 가리키는 노드의 다음 노드

    while(prev != NULL && delete != NULL) { // 이전 노드와 삭제할 노드 모두 있을 때까지 반복문 실행
        prev->link = delete->link; // 이전 노드의 다음 노드는 삭제할 노드의 다음 노드이어야 함
        prev = prev->link; // 이전 노드는 삭제할 노드의 다음 노드로 이동

        free(delete); // 삭제할 노드 동적 할당 해제

        if(prev != NULL) { // 아직 마지막 노드에 도달하지 않았다면, 
            delete = prev->link; // 그 다음 노드는 삭제할 노드
        } else { // 마지막 노드에 도달하면
            delete = NULL; // 삭제할 노드는 없으므로 NULL
        }
    }

    plist->tail = prev; // 포인터 헤더의 tail은 prev 노드, 마지막 노드를 가리킴

    return plist->head; 
}
```
