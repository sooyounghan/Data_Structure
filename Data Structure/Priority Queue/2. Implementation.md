-----
### 우선순위 큐 구현 방법
-----
1. 배열을 사용하는 방법
   - 정렬이 되어 있지 않은 배열을 사용하는 경우
     + 삽입은 배열의 맨 끝에 새로운 요소를 추가하면 되므로 시간 복잡도는 O(1)
     + 삭제를 할 때는 가장 우선 순위가 높은 요소를 찾아야하므로 처음부터 끝까지 모든 요소 확인해야 하므로, 시간 복잡도 O(n)
     + 요소를 삭제한 뒤에는, 뒤에 있는 요소들을 앞으로 이동시켜야 함

   - 정렬이 되어있는 배열의 경우
     + 새로운 요소를 삽입할 때는 다른 요소의 값을 비교하여 적절한 삽입 위치 결정
     + 삽입 위치를 찾기 위해 순차 탐색이나 이진 탐색과 같은 방법 가능
     + 삽입 위치를 찾은 이후에는 삽입 위치 뒤 요소들을 이동시켜 빈자리를 만든 다음 삽입
     + 따라서, 삽입 시 시간 복잡도는 일반적으로 O(n)
     + 삭제의 경우 숫자가 높은 것이 우선순위가 높다고 가정하면 맨 뒤의 위치한 요소 삭제하면 되므로 시간 복잡도 O(1)
<div align="center">
<img src="https://github.com/user-attachments/assets/808c4cd0-48ef-4fce-a133-6f5c3270e4fd">
</div>

2. 연결 리스트 사용하는 방법
   - 정렬된 상태 또는 정렬되지 않은 상태로 연결리스트 사용 가능
   - 정렬이 안 된 리스트라면 삽입 시에는 첫 번째 노드로 삽입하는 것이 유리
      + 또한 삽입 시 배열과 달리 다른 노드를 이동할 필요가 없이 포인터만 변경하면 되므로 삽입 시간 복잡도는 O(1)
      + 삭제 시에는 포인터를 따라 모든 노드를 뒤져봐야 하므로 시간 복잡도 O(n)

   - 정렬된 리스트의 경우에는 우선 순위가 높은 요소가 앞에 위치하는 것이 유리
     + 우선 순위가 높은 요소가 첫 번째노드가 되도록 하며, 삽입 시 우선순위 값 기준으로 삽입 위치를 찾아야하므로 O(n)
     + 삭제 시에는 첫 번째 노드만 삭제하면 되므로 O(1)

<div align="center">
<img src="https://github.com/user-attachments/assets/f68c73c3-2924-4e1b-886a-a96304ae2d41">
</div>

3. 히프를 사용하는 방법
   - 히프(Heap) : 완전 이진 트리의 일종으로 우선순위 큐를 위해 만들어진 특별한 자료 구조로, 일종의 느슨한 정렬 상태 유지
   - 즉, 완전히 정렬된 것은 아니지만, 전혀 정렬이 안 된 것도 아닌 상태를 유지
   - 느슨한 정렬 상태를 유지하여 우선순위 큐를 구현
   - 히프의 효율은 $O(\log_2 n)$으로서 다른 방법보다 상당히 유리
     + n이 1000인 경우, O(n) 알고리즘은 1000초, $O(\log_2 n)$ 알고리즘은 10초에 불과
<div align="center">
<img src="https://github.com/user-attachments/assets/8911eb71-e857-49b6-96f2-a7f0218d38e8">
</div>
