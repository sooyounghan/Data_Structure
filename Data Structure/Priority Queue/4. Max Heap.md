-----
### 히프의 구현
-----
1. 히프의 정의
   - 1차원 배열로 표현될 수 있으므로, 히프의 각 요소들을 구조체 element로 정의
   - element의 1차원 배열로 만들어 히프 구현
   - heap_size는 현재 히프 안에 저장된 요소 개수
```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_ELEMENT 200

typedef struct {
    int key; // 노드의 키 값
} element; // element 구조체 정의

typedef struct {
    element heap[MAX_ELEMENT]; // heap 정의
    int heap_size; // 현재 히프 안에 저장된 요소의 개수
} HeapType;
```

2. Heap의 생성
```c
HeapType heap;
```
  - 동적 생성도 가능
```c
HeapType *heap = (HeapType *)malloc(sizeof(HeapType); // 메모리 동적 할당 이용
````

3. 삽입 연산
   - 💡 히프에 새로운 요소가 들어오면, 일단 새로운 노드를 히프의 마지막 노드로 삽입
   - 마지막 노드 다음에 새로운 노드를 위치시키면 히프 트리의 성질이 만족되지 않을 수 있음
   - 따라서, 삽입 후 새로운 노드를 부모 노드들과 교환하여 히프 성질을 만족시켜야 함
   - 즉, 히프를 재구성
   - 예) 최대 히프에 8을 삽입한다고 가정  
   - 첫 번쨰 : 먼저 번호순으로 가장 마지막에 위치에 이어서 새로운 요소 8이 삽입
<div align="center">
<img src="https://github.com/user-attachments/assets/b0a50752-2e7e-44a0-971d-6201536c346c">
</div>

   - 부모 노드 4와 비교하여 삽입 노드 8이 더 크므로 교환
<div align="center">
<img src="https://github.com/user-attachments/assets/e2a90fe7-5f8a-4e36-aa41-643248c047b3">
</div>

   - 부모 노드 7과 비교하여 삽입 노드 8이 더 크므로 교환
<div align="center">
<img src="https://github.com/user-attachments/assets/d3858f97-bcec-4604-9fa6-6fc8f1bc39be">
</div>

   - 삽입 노드 8이 부모 노드 9보다 작으므로 더 이상 교환하지 않음

   - 의사 코드와 알고리즘
<div align="center">
<img src="https://github.com/user-attachments/assets/ba213f69-0923-4d8e-9153-d5fc3e696568">
</div>

   - 실제 구현은 바로 교환이 아닌, 부모 노드를 끌어내린 다음, 삽입될 위치가 확실히 정해지면 최종적으로 새로운 노드를 그 위치로 이동
```c
// 현재 요소의 개수가 heap_size인 히프 h에 item을 삽입하는 함수
void insert_max_heap(HeapType* h, element item) {
    int i; // 마지막 위치에 저장하기 위한 변수
    i = ++(h->heap_size); // i는 마지막 위치로 가기 위해 heap_size + 1

    // 트리를 거슬러 올라가면서 부모 노드와 비교 과정
    while((i != 1) && (item.key > h->heap[i / 2].key)) { // i = 1인 경우 루트노드이며 이 경우가 아닌 경우와, item 값이 부모 노드보다 크면, 교환 필요
        h->heap[i] = h->heap[i / 2]; // 부모 노드의 값을 자식 노드에 값에 저장
        i /= 2; // 부모 노드 인덱스로 이동        
    }
    h->heap[i] = item; // 만약, 삽입 위치를 찾으면 저장된 인덱스 위치에 저장
}
```



