-----
### 2-3-4 Tree
-----
1. 2-3-4 트리는 하나의 노드가 4개의 자식까지 가질 수 있도록 2-3 트리 확장
2. 4개의 자식을 가질 수 있는 노드는 4-노드라고 불리며, 3개의 데이터를 가질 수 있음
3. 4-노드의 3개의 데이터를 각 small, middle, large라고 하면 4-노드의 서브트리에는 같은 범위에 속하는 데이터들이 들어감
<div align="center">
<img src="https://github.com/user-attachments/assets/9eb89007-99eb-4939-98cc-7c7ca0a4ae5b">
</div>

   - 2-3-4 트리를 탐색하는 것은 2-3ㅌ트리의 탐색 알고리즘에 4-노드를 처리하는 부분만 추가

4. 2-3-4 트리의 삽입 연산
   - 키를 삽입해야 할 단말 노드가 만약 2-노드 또는 3-노드이면 간단하게 삽입
   - 문제는 삽입해야 할 단말노드가 4-노드이면 후진 분할(Backward Split) 발생
     + 따라서, 2-3-4 노드에서는 후진 분할 연산 방지를 위해 삽입 노드를 찾는 순회(루트 → 단말) 시에 4-노드를 만나면 미리 분할 수행
     + 따라서, 미리 분할을 수행하였으므로 후진 분할을 할 필요가 없으며, 이것이 2-3트리와 비교점
     + 2-3 트리는 삽입 또는 삭제를 위한 순회(루트 → 단말)와 분할과 합병으로 인한 순회(단말 → 루트)가 필요
     + 따라서, 2-3 트리에 비해 2-3-4 트리의 장점은 루트에서 단말 노드로 한 번만 이동하면서 삽입과 삭제가 가능
  - 2-3-4 트리에서는 삽입을 위해 루트에서 단말 노드로 내려가는 동안 4-노드를 만나면 무조건 분할
  - 따라서, 단말 노드에 도달하게 되면 단말노드의 부모 노드는 4-노드가 아닌 것이 보장되며, 후진 이동을 막을 수 있음

5. 4-노드에서의 3가지의 경우
   - 편의상 노드들의 경우가 대칭인 경우는 생략
   - 노드가 삽입할 때 루트에서 단말 노드로 내려가면서 4-노드를 분할한다면 적어도 루트가 아닌 4-노드를 만날 때마다 그것의 부모는 적어도 4-노드가 아님을 알 수 있음
<div align="center">
<img src="https://github.com/user-attachments/assets/14c8dbc8-78cb-4643-a743-ee3f40bd5359">
</div>
