-----
### 정렬 (Sorting)
-----
1. 물건을 크기 순으로 오름차순(Asceding Order)이나 내림차순(Descending Order)으로 나열하는 것
2. 컴퓨터 공학에서 가장 기본적이고 중요한 알고리즘 중 하나로 일상생활에서 많이 사용
3. 자료 탐색에 있어서 필수적이며, 정렬되어 있지 않은 자료가 주어지지 않으면 탐색의 효율성은 크게 떨어짐
4. 일반적으로 정렬 시켜야 할 대상 : 레코드 (Record)
   - 레코드는 다시 필드(Field)라는 단위로 나누어짐
     + 예) 학생들의 레코드 : 이름, 학번, 주소, 전화번호 등이 필드
   - 여러 필드 중 특별히 레코드와 레코드를 식별해주는 역할을 하는 필드 : 키(Key)
     + 예) 학생들의 레코드 경우 학번이 키가 될 수 있음
   - 즉, 정렬이란 결국 레코드 값을 키 값 순서로 재배열하는 것
<div align="center">
<img src="https://github.com/user-attachments/assets/4cb3fb34-4ff3-4cec-9283-aa87a8b5d79f">
</div>

5. 정렬 알고리즘은 매우 많지만, 모든 경우에 있어서 최상의 성능을 보여주는 최적 알고리즘은 존재하지 않음
   - 현재의 프로그램 수행환경에서 가장 효율적인 정렬 알고리즘을 선택해야 함
   - 대개 정렬 알고리즘을 평가하는 효율성의 기준은 정렬을 위해 필요한 비교 연산 횟수와 이동 연산의 횟수
   - 이들 횟수를 정확하게 구하기 힘드므로, 이들 횟수를 빅오 표기법을 이용해 근사적으로 표현
   - 이들 횟수는 자료 초기화 여부에 의존적이며, 이동 횟수와 비교 횟수가 서로 비례하지 않음
   - 즉, 어떤 알고리즘은 비교 횟수는 많지만, 이동 횟수는 적을 수 있고 반대도 가능

6. 정렬 알고리즘
   - 단순하지만 비효율적인 정렬 알고리즘 : 삽입 정렬, 선택 정렬, 버블 정렬 등 (구현하기가 쉬움)
   - 복잡하지만 효율적인 정렬 알고리즘 : 퀵 정렬, 히프 정렬, 합병 정렬, 기수 정렬 등 (구현하기가 까다로움)
   - 대개 자료의 수가 적다면 단순한 정렬 방법 사용도 좋지만, 자료의 개수가 일정 개수를 넘어가면 반드시 효율적인 알고리즘 사용

7. 정렬 알고리즘은 내부 정렬(Internal Sorting)과 외부 정렬(External Sorting)으로 구분
   - 내부 정렬 : 정렬 전 모든 데이터가 메인 메모리에 올라와 있는 정렬
   - 외부 정렬 : 외부 기억 장치에 대부분 데이터가 있으며, 일부만 메모리에 올려놓은 상태에서 정렬

8. 정렬 알고리즘을 안정성(Stability) 측면으로 분류 가능
   - 정렬 알고리즘에서 안정성이란 입력 데이터에 동일한 키 값을 갖는 레코드가 여러 개 존재할 경우, 이들 레코들의 상대적인 위치가 정렬 후에도 바뀌지 않음을 뜻함
   - 반대로 같은 키 값을 갖는 레코드들이 정렬 후에 위치가 바뀌게 되면 안정하지 않다고 함
<div align="center">
<img src="https://github.com/user-attachments/assets/075567e6-d0d7-448c-9ab3-d730c92a24d3">
</div>

   - 키 값 30을 갖는 두 개의 레코드가 정렬 후 위치가 바뀜
   - 정렬의 안정성이 필수적으로 요구되는 경우 정렬 알고리즘 중 안정성을 충족하는 삽입정렬, 버블정렬, 합병정렬 등을 사용해야 함
