-----
### 쉘 정렬 (Shell Sort)
-----
1. Donald L. Shell이라는 사람이 제안한 방법으로, 삽입 정렬이 어느 정도 정렬된 배열에 대해서 대단히 빠른 것에 착안한 방법
2. 셀 정렬은 삽입 정렬의 $O(n^2)$보다 빠름
3. 삽입 정렬의 최대의 문제점 : 요소들이 삽입될 때, 이웃한 위치로만 이동
   - 만약 삽입되어야 할 위치가 현재 위치에서 상당히 멀리 떨어진 곳이라면 많은 이동을 해야만 제자리로 갈 수 있음
   - 하지만, 쉘 정렬은 요소들이 멀리 떨어진 위치로도 이동 가능
4. 쉘 정렬은 전체 리스트를 한 번에 정렬하지 않음
   - 대신 먼저 정렬해야 할 리스트를 일정 기준에 따라 분류하여 연속적이지 않은 여러 개의 부분 리스트를 만들고, 각 부분 리스트를 삽입 정렬을 이용해 정렬
   - 모든 부분 리스트가 정렬되면 쉘 정렬은 다시 전체 리스트를 더 적은 개수의 부분 리스트로 만든 후 알고리즘을 되풀이ㅣ
   - 즉, 부분 리스트의 개수가 1이 될 때까지 되풀이
5. 부분 리스트를 구성할 때는 주어진 리스트의 각 $k$번째 요소를 추출하여 만드는데, $k$를 간격(Gap)이라고 함
   - 쉘 정렬에서는 각 스텝마다 간격 k를 줄여나가므로 수행 과정이 반복될 때마다 하나의 부분 리스트에 속하는 레코드들의 개수가 증가
   - 마지막 스텝에서는 간격의 값이 1

6. 예를 들어, 리스트가 (10, 8, 6, 20, 4, 3, 22, 1, 0, 15, 16)의 수행 과정
<div align="center">
<img src="https://github.com/user-attachments/assets/03608348-dc07-4b71-8255-fac9bf1043bf">
</div>

   - (a)와 같이 입력 리스트의 각 5번째 요소를 추출하여 부분 리스트를 만ㄴ듬
   - 첫 번째 부분 리스트는 10, 3, 16을 포함하며, 두 번째 부분 리스트는 8, 22를 포함하는 형식으로 부분 리스트로 구성
   - 다음, 각 부분 리스트에 대해 삽입 정렬 수행
   - 부분 리스트들이 정렬된 후에는 전체 리스트도 약간의 정렬된 것 확인
   - 실제로 부분 리스트들이 만들어지는 것이 아닌, 일정 간격으로 삽입 정렬이 수행되므로, 추가 공간은 필요 없음

6. 쉘 정렬의 첫 패스가 끝나면 비슷한 방식으로 다시 부분 리스트를 구성하는데, 간격을 1/2을 줄여서 입력 배열의 2번째 요소를 추출하여 부분 리스트 생성
   - 간격은 처음에 &n div 2$로 하고, 각 패스마다 간격을 절반으로 줄이는 방식으로 많이 사용
<div align="center">
<img src="https://github.com/user-attachments/assets/ebe366ef-8ebe-4f7f-a2ef-4876248b1812">
</div>

7. 쉘 정렬 구현
   - gap : 간격을 나타냄
   - shell_sort 함수 : 간격이 1이 될 때까지, 간격을 1/2로 줄이면서 반복
   - 부분 리스트의 개수는 gap이 되며, 각 부분 리스트에 대해 일정한 간격으로 떨어져 있는 요소들을 삽입 정렬하는 함수인 inc_insertion_sort를 호출
     + 만약 간격이 짝수이면 1을 더하는 것이 더 좋은 것으로 분석되어, 1을 더함
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_SIZE 10

// 전역 변수
int list[MAX_SIZE]; // 정렬할 배열
int n;

// 간격 gap만큼 떨어진 요소들을 삽입 정렬 (정렬 범위는 first ~ last)
void inc_insertion_sort(int list[], int first, int last, int gap) {
    int i, j, key;

    for(i = first + gap; i <= last; i = i + gap) { // 부분 리스트의 first의 다음 간격(Gap)부터 마지막 요소까지에 대해 반복
        key = list[i]; // 해당하는 i의 인덱스의 값을 key로 저장

        for(j = i - gap; j >= first && key < list[j]; j = j - gap) { // 부분 리스트 내 정렬 시작 (역순으로 조회하므로, i의 인덱스의 전 간격(gap)부터 첫번째 요소까지 반복)
            list[j + gap] = list[j]; // key(한 간격 앞에 있는 값) 값이 역순으로 전 간격에 있는 값보다 작으면, 이는 정렬해야하는 것이므로, 현재 한 간격 앞에 있는 값을 오른쪽으로 한 칸 씩 이동 (오름차순 정렬) 
        }

        list[j + gap] = key; // 오른쪽으로 이동한 값 왼쪽에 key 값 삽입
    }
}

// Shell 정렬
void shell_sort(int list[], int n) { // n = size
    int i, gap; // gap은 간격
    
    for(gap = n / 2; gap > 0; gap = gap / 2) { // 간격은 처음 리스트 크기의 1/2부터 시작해, 점진적으로 절반씩 줄여나감
        if(gap % 2 == 0) { 
            gap++; // 간격을 2로 나눈 값이 0, 즉 짝수라면 1 증가하는 것이 더 좋음
        }    

        for(i = 0; i < gap; i++) { // 부분 리스트의 개수 : gap
            inc_insertion_sort(list, i, n - 1, gap); // 리스트에 대해 간격씩 정렬
        }
    }
}
int main(void) {
    int i;
    n = MAX_SIZE;

    srand(time(NULL)); // 난수 생성 및 출력
    for(i = 0; i < n; i++) { 
        list[i] = rand() % 100; // 난수 발생 범위 : 0 ~ 99
    }

    shell_sort(list, n); // 버블 정렬 호출
    
    for(i = 0; i < n; i++) {
        printf("%d ", list[i]);
    }

    printf("\n");

    return 0;
}
```
  - 실행 결과
```
9 10 12 17 17 51 55 62 91 93 
```

8. 쉘 정렬 분석
   - 연속적이지 않은 부분 리스트에서 자료 교환이 발생하면 더 큰 거리를 이동
     + 반면 삽입 정렬에서는 한 번에 한 칸씩만 이동
     + 따라서, 교환되는 아이템들이 삽입 정렬보다는 최종 위치에 더 가까이 있을 가능성이 높음

   - 부분 리스트는 어느 정도 정렬이 된 상태이므로, 부분 리스트의 개수가 1이 되면, 쉘 정렬은 기본적으로 삽입 정렬을 수행하는 것이지만 빠르게 수행
     + 삽입 정렬은 거의 정렬된 리스트에 대해서 빠르게 수행됨

   - 최악의 경우 시간 복잡도 : $O(n^2)$, 평균적인 경우 $O(n^{1.5})$
