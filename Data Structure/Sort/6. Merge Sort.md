-----
### 합병 정렬 (Merge Sort)
-----
1. 입력 데이터가 많으면서 자주 정렬해야 할 필요가 있을 때 유용
2. 합병 정렬(Merge Sort)은 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 부분 리스트를 합하여 전체가 정렬된 리스트를 얻고자 하는 것
3. 분할-정복(Divide and Conquer0 기법에 바탕을 둠
   - 분할 정복 기법은 작은 2개의 문제를 분리하고, 각각을 해결한 다음, 결과를 모아서 원래 문제를 해결하는 전략
   - 분리가 아직도 해결하기 어렵다면, 즉 충분히 작지 않다면 분할 정복 방법을 연속하여 다시 적용
   - 대개 순환 호출을 이용해 구현
     + 분할 (Divide) : 입력 배열을 같은 크기의 2개의 부분 배열로 분할
     + 정복 (Conquer) : 부분 배열을 정렬, 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용해 다시 분할 정복 기법 적용
     + 결합 (Combine) : 정렬된 부분 배열들을 하나의 배열에 통합
<div align="center">
<img src="https://github.com/user-attachments/assets/eb89f694-641f-412b-8ad0-3181757594ef">
</div>

4. 예시) 다음과 같은 배열이 있다고 가정 : [27, 10, 12, 20, 25, 13, 15, 22]
   - 분할 (Divide) : 배열을 [27, 10, 12, 20]과 [25, 13, 15, 22]의 2개의 부분 배열로 나눔
   - 정복 (Conquer) : 부분 배열을 정렬하여 [10, 12, 20, 27]과 [13, 15, 22, 25]를 얻음
   - 결합 (Combine) : 부분 배열을 통합하여 [10, 12, 13, 15, 20, 22, 25, 27]를 얻음

5. 부분 배열들을 정렬할 때도 합병 정렬을 순환적으로 이용
   - 즉, 위의 예에서 부분 배열인 [27, 10, 12, 20]를 정렬할 때도 합병 정렬 개념을 다시 적용
   - 즉, 합병 정렬 함수의 순환적 호출을 이용해 구현
<div align="center">
<img src="https://github.com/user-attachments/assets/09e2b5b7-396f-4232-903f-518238b4b958">
</div>

6. 합병 정렬 알고리즘
<div align="center">
<img src="https://github.com/user-attachments/assets/71d088e2-b67d-4ec6-a8b3-d3317f865c9c">
</div>

  - 💡 합병 정렬에서 실제로 정렬이 이루어지는 시점 : 2개의 리스트를 합병(Merge)하는 단계
  - 정렬된 2개의 배열을 합병하는 알고리즘
    + 합병 정렬은 이 알고리즘을 사용
    + 합병 자체는 어렵지 않지만, 추가적 리스트를 필요로 함
    + 합병 알고리즘은 2개의 리스트의 요소들을 처음부터 하나씩 비교하여 두 개의 리스트 요소 중 더 작은 요소를 새로운 리스트로 옮김
    + 둘 중 하나가 끝날 때까지 이 과정 되풀이
    + 만약, 둘 중 하나의 리스트가 먼저 끝나게 되면, 나머지 리스트의 요소들을 전부 새로운 리스트로 복사
<div align="center">
<img src="https://github.com/user-attachments/assets/93890667-efaa-4639-9835-4da5fe4a4db9">
</div>

  - 배열 A의 첫 번째 요소인 2와 B의 첫 번째 요소인 1을 비교하여 1이 더 작으므로 1을 배열 C로 옮김
  - 다음으로, A의 2와 B의 다음 숫자인 3을 비교
  - A의 2가 B의 3보다 작으므로 이번에는 A의 2를 C로 이동
  - 두 개의 리스트 중 하나가 먼저 끝날 때까지 이 과정 반복
  - 두 개의 리스트 중 하나가 먼저 끝나면 나머지 요소들을 리스트 C로 복사
<div align="center">
<img src="https://github.com/user-attachments/assets/75becb9b-2163-4cb7-8acd-a1ecddd0fbc1">
</div>

  - 위의 합병 알고리즘에서 하나의 배열 안에 두 개의 정렬된 부분 리스트가 저장되어 있다가 가정
  - 즉, 첫 번쨰 부분 리스트는 list[left]부터 list[mid]까지, 두 번째 부분 리스트는 list[mid + 1]부터 list[right]까지임
  - 합병된 리스트를 임시로 저장하기 위해 배열 sorted 사용
<div align="center">
<img src="https://github.com/user-attachments/assets/2b2f50b4-019e-4ee6-a0a9-c561e19b830e">
</div>

7. 구현
   - merge_sort 함수에서 주어진 list 배열을 2등분하여 각 부분 배열에 대해 다시 merge_sort 함수를 순환 호출
   - 이러한 과정은 결국 부분 배열 숫자가 하나 남을때 까지 계속됨
   - 분할 과정이 끝나면 정렬된 부분 뱅려을 merge 함수를 이용해 합병하는 과정 시작
   - 실제로, 숫자가 정렬되는 곳은 이 합병 과정임
   - merge 함수는 부분 배열들의 숫자를 임시 배열에 정렬된 상태로 다시 원 배열에 복사
```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_SIZE 10

// 전역 변수
int list[MAX_SIZE]; // 정렬할 배열
int sorted[MAX_SIZE]; // 정렬하기 위해 필요한 추가 공간간
int n;

/*
    1. i : 정렬된 왼쪽 리스트에 대한 인덱스
    2. j : 정렬된 오른쪽 리스트에 대한 인덱스
    3. k : 정렬될 리스트에 대한 인덱스
*/
// 합병 정렬 알고리즘
void merge(int list[], int left, int mid, int right) {
    int i, j, k, l;

    i = left;
    j = mid + 1;
    k = left;

    // 분할 정렬된 list의 합병
    while(i <= mid && j <= right) {
        if(list[i] <= list[j]) {
            sorted[k++] = list[i++];
        } else {
            sorted[k++] = list[j++];
        }
    }

    if(i > mid) { // 남아 있는 레코드 일괄 복사
        for(l = j; l <= right; l++) {
            sorted[k++] = list[l];
        }
    } else {
        for(l = i; l <= right; l++) {
            sorted[k++] = list[l];
        }
    }

    // 배열 sorted[]의 리스트를 배열 list로 재복사
    for(l = left; l <= right; l++) {
        list[l] = sorted[l];
    }
}

// 합병 정렬 함수
void merge_sort(int list[], int left, int right) {
    int mid;

    if(left < right) {
        mid = (left + right) / 2; // 리스트 균등 분할

        merge_sort(list, left, mid); // 부분 리스트 정렬
        merge_sort(list, mid + 1, right); // 부분 리스트 정렬

        merge(list, left, mid, right); // 합병
    }
}

int main(void) {
    int i;
    n = MAX_SIZE;

    srand(time(NULL)); // 난수 생성 및 출력
    for(i = 0; i < n; i++) { 
        list[i] = rand() % 100; // 난수 발생 범위 : 0 ~ 99
    }

    merge_sort(list, 0, n - 1); // 합병 정렬 호출
    
    for(i = 0; i < n; i++) {
        printf("%d ", list[i]);
    }

    printf("\n");

    return 0;
}
```
  - 실행 결과
```
14 28 33 34 35 57 61 68 75 78
```

8. 합병 정렬의 복잡도 분석
   - 합병 정렬은 순환 호출로 구성
   - 레코드의 개수를 $n$이 $2^n$으로 가정하고 순환호출 깊이 분석
     + $n = 2^3$인 경우 부분 배열의 크기는 $2^3 → 2^2 → 2^1 → 2^0$ 순으로 줄어들어 순환 호출의 깊이가 3
     + 일반적으로 $n = 2^k$라고 하면, 부분 배열의 크기는 $2^k → 2^{k-1} → ... → 2^0$이 되어 순환 호출의 깊이가 $k$가 될 것 : $k = log_2 n$

   - 배열이 부분 배열로 나누어지는 단계에서는 비교 연산이나 이동 연산은 수행되지 않음
   - 💡 부분 배열이 합쳐지는 merge 함수에서 비교 연산과 이동 연산이 수행되는 것
     + 순환 호출 깊이 만큼 합병 단계가 필요
     + $n = 2^3$의 경우
       * 크기가 1인 부분 배열 2개 합병 : 최대 2개의 비교 연산 필요, 부분 배열의 쌍은 4개이므로 $2 * 4 = 8$번의 비교 연산 필요
       * 크기가 2인 부분 배열 2개 합병 : 최대 4개의 비교 연산 필요, 부분 배열의 쌍은 2개이므로 $4 * 2 = 8$번의 비교 연산 필요
       * 크기가 4인 부분 배열 2개 합병 : 최대 8개의 비교 연산 필요, 부분 배열의 쌍은 8개이므로 $8 * 1 = 8$번의 비교 연산 필요

     + 따라서, 하나의 합병 단계에서는 최대 $n$번의 비교 연산이 필요
     + 💡 합병 단계가 $k = log_2 n$번 만큼 있으므로 총 비교 연산은 $n log_2 n$번 필요

   - 💡 이동 연산의 경우, 하나의 합병 단계에서 보면 임시 배열에 복사했다가 다시 가져와야 되므로 이동 연산은 총 부분 배열에 들어 있는 요소의 개수가 $n$인 경우, 레코드의 이동은 $2n$번 발생하므로 하나의 합병 단계에서 $2n$개 필요
   - 결론적으로 합병 정렬은 비교 연산과 이동 연산의 경우 $O(n log_2 n)$의 복잡도를 가지는 알고리즘
  
   - 합병 정렬은 안정적인 정렬 방법이며, 데이터 분포의 영향을 덜 받음
   - 즉, 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일
   - 즉, 최악 / 평균 / 최선의 경우 모두 다 $O(n log_2 n)$인 정렬 방법

9. 단, 합병 정렬의 경우 임시 배열이 필요하며, 만약 레코드들의 크기가 큰 경우 이동 횟수가 많으므로 합병 정렬은 매우 큰 시간적 낭비 초래
    - 하지만, 만약 레코드를 연결 리스트로 구성하여 합병 정렬할 경우, 링크 인덱스만 변경하면 되므로 데이터 이동은 무시할 수 있을 정도로 작아짐
    - 따라서, 크기가 큰 레코드를 정렬할 경우, 만약 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬응 포함한 다른 어떤 정렬 방법보다 효율적일 수 있음
